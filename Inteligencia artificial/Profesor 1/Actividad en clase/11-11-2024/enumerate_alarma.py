# -*- coding: utf-8 -*-
"""enumerate_alarma.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PE4D48ck3OGttTF9pQ4LagcENsZtj-My
"""

class BayesNet:
    def __init__(self):
        self.variables = []
        self.parents = {}
        self.probabilities = {}

    def add_variable(self, variable):
        self.variables.append(variable)
        self.parents[variable] = []

    def add_parent(self, child, parent):
        self.parents[child].append(parent)

    def add_probability(self, variable, parents, probabilities):
        self.probabilities[(variable, parents)] = probabilities

    def get_values(self, variable):
        return [True, False]

    def P(self, variable, value, evidence):
        parents = self.parents[variable]
        parent_values = tuple(evidence[parent] for parent in parents)
        probabilities = self.probabilities[(variable, parent_values)]
        return probabilities[value]




def enumeration_ask(X, e, bn):
    Q = {}
    for xi in bn.get_values(X):
        exi = extend(e, X, xi)
        Q[xi] = enumerate_all(bn.variables, exi, bn)
        print("Q[xi]) = ",Q[xi])
    alpha = 1.0 / sum(Q.values())  # Cálculo de α
    print(alpha)
    for key in Q:
        Q[key] *= alpha  # Multiplicación por α para normalizar

    return Q




def enumerate_all(vars, e, bn):
    # Si no quedan variables por considerar, se ha llegado al final de la recursión
    if not vars:
        return 1.0

    # Se obtiene la primera variable de la lista de variables
    Y = vars[0]

    # Si la variable está en la evidencia, se calcula la probabilidad
    #condicional y se continúa la recursión
    if Y in e:
        return bn.P(Y, e[Y], e) * enumerate_all(vars[1:], e, bn)

    else:
        total = 0.0

        # Se itera sobre los posibles valores de la variable
        for y in bn.get_values(Y):
            # Se extiende la evidencia con el valor actual de la variable
            ey = extend(e, Y, y)
            # Se calcula la probabilidad condicional y se continúa la recursión
            total += bn.P(Y, y, e) * enumerate_all(vars[1:], ey, bn)
            print(total)
        return total



def extend(e, var, value):
    # Se crea una copia de la evidencia actual
    extended = e.copy()
    # Se agrega o actualiza el valor de la variable var en la evidencia extendida
    extended[var] = value
    # Se devuelve la evidencia extendida
    return extended


# Define the Bayesian network
bn = BayesNet()

# Add variables
bn.add_variable('rain')
bn.add_variable('maintenance')
bn.add_variable('train')
bn.add_variable('appointment')

# Define parent relationships
bn.add_parent('maintenance', 'rain')
bn.add_parent('train',       'rain')
bn.add_parent('train',       'maintenance')
bn.add_parent('appointment', 'train')


# Add probabilities
bn.add_probability('rain', (), {none: 0.7,light: 0.2,heavy:0.1})
bn.add_probability('maintenance', (), {yes:,no:})
bn.add_probability('train', (True, True), {on time: ,delayed:})
bn.add_probability('appointment', (True, False), {attend:, miss:})


# Se definen las variables de consulta y la evidencia
query_variable = 'B'
evidence = {'J': True, 'M': True}

# Se realiza la consulta usando enumeration_ask
result = enumeration_ask(query_variable, evidence, bn)
print(result)